{
  "version": 3,
  "sources": ["../../@hookform/resolvers/src/validateFieldsNatively.ts", "../../@hookform/resolvers/src/toNestErrors.ts", "../../@hookform/resolvers/node_modules/zod/dist/esm/v4/core/core.js", "../../@hookform/resolvers/node_modules/zod/dist/esm/v4/core/util.js", "../../@hookform/resolvers/node_modules/zod/dist/esm/v4/core/errors.js", "../../@hookform/resolvers/node_modules/zod/dist/esm/v4/core/parse.js", "../../@hookform/resolvers/zod/src/zod.ts"],
  "sourcesContent": ["import {\n  FieldError,\n  FieldErrors,\n  FieldValues,\n  Ref,\n  ResolverOptions,\n  get,\n} from 'react-hook-form';\n\nconst setCustomValidity = (\n  ref: Ref,\n  fieldPath: string,\n  errors: FieldErrors,\n) => {\n  if (ref && 'reportValidity' in ref) {\n    const error = get(errors, fieldPath) as FieldError | undefined;\n    ref.setCustomValidity((error && error.message) || '');\n\n    ref.reportValidity();\n  }\n};\n\n// Native validation (web only)\nexport const validateFieldsNatively = <TFieldValues extends FieldValues>(\n  errors: FieldErrors,\n  options: ResolverOptions<TFieldValues>,\n): void => {\n  for (const fieldPath in options.fields) {\n    const field = options.fields[fieldPath];\n    if (field && field.ref && 'reportValidity' in field.ref) {\n      setCustomValidity(field.ref, fieldPath, errors);\n    } else if (field && field.refs) {\n      field.refs.forEach((ref: HTMLInputElement) =>\n        setCustomValidity(ref, fieldPath, errors),\n      );\n    }\n  }\n};\n", "import {\n  Field,\n  FieldErrors,\n  FieldValues,\n  InternalFieldName,\n  ResolverOptions,\n  get,\n  set,\n} from 'react-hook-form';\nimport { validateFieldsNatively } from './validateFieldsNatively';\n\nexport const toNestErrors = <TFieldValues extends FieldValues>(\n  errors: FieldErrors,\n  options: ResolverOptions<TFieldValues>,\n): FieldErrors<TFieldValues> => {\n  options.shouldUseNativeValidation && validateFieldsNatively(errors, options);\n\n  const fieldErrors = {} as FieldErrors<TFieldValues>;\n  for (const path in errors) {\n    const field = get(options.fields, path) as Field['_f'] | undefined;\n    const error = Object.assign(errors[path] || {}, {\n      ref: field && field.ref,\n    });\n\n    if (isNameInFieldArray(options.names || Object.keys(errors), path)) {\n      const fieldArrayErrors = Object.assign({}, get(fieldErrors, path));\n\n      set(fieldArrayErrors, 'root', error);\n      set(fieldErrors, path, fieldArrayErrors);\n    } else {\n      set(fieldErrors, path, error);\n    }\n  }\n\n  return fieldErrors;\n};\n\nconst isNameInFieldArray = (\n  names: InternalFieldName[],\n  name: InternalFieldName,\n) => {\n  const path = escapeBrackets(name);\n  return names.some((n) => escapeBrackets(n).match(`^${path}\\\\.\\\\d+`));\n};\n\n/**\n * Escapes special characters in a string to be used in a regex pattern.\n * it removes the brackets from the string to match the `set` method.\n *\n * @param input - The input string to escape.\n * @returns The escaped string.\n */\nfunction escapeBrackets(input: string): string {\n  return input.replace(/\\]|\\[/g, '');\n}\n", "export /*@__NO_SIDE_EFFECTS__*/ function $constructor(name, initializer, params) {\n    function init(inst, def) {\n        var _a;\n        Object.defineProperty(inst, \"_zod\", {\n            value: inst._zod ?? {},\n            enumerable: false,\n        });\n        (_a = inst._zod).traits ?? (_a.traits = new Set());\n        inst._zod.traits.add(name);\n        initializer(inst, def);\n        // support prototype modifications\n        for (const k in _.prototype) {\n            if (!(k in inst))\n                Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });\n        }\n        inst._zod.constr = _;\n        inst._zod.def = def;\n    }\n    // doesn't work if Parent has a constructor with arguments\n    const Parent = params?.Parent ?? Object;\n    class Definition extends Parent {\n    }\n    Object.defineProperty(Definition, \"name\", { value: name });\n    function _(def) {\n        var _a;\n        const inst = params?.Parent ? new Definition() : this;\n        init(inst, def);\n        (_a = inst._zod).deferred ?? (_a.deferred = []);\n        for (const fn of inst._zod.deferred) {\n            fn();\n        }\n        return inst;\n    }\n    Object.defineProperty(_, \"init\", { value: init });\n    Object.defineProperty(_, Symbol.hasInstance, {\n        value: (inst) => {\n            if (params?.Parent && inst instanceof params.Parent)\n                return true;\n            return inst?._zod?.traits?.has(name);\n        },\n    });\n    Object.defineProperty(_, \"name\", { value: name });\n    return _;\n}\n//////////////////////////////   UTILITIES   ///////////////////////////////////////\nexport const $brand = Symbol(\"zod_brand\");\nexport class $ZodAsyncError extends Error {\n    constructor() {\n        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);\n    }\n}\nexport const globalConfig = {};\nexport function config(newConfig) {\n    if (newConfig)\n        Object.assign(globalConfig, newConfig);\n    return globalConfig;\n}\n", "// functions\nexport function assertEqual(val) {\n    return val;\n}\nexport function assertNotEqual(val) {\n    return val;\n}\nexport function assertIs(_arg) { }\nexport function assertNever(_x) {\n    throw new Error();\n}\nexport function assert(_) { }\nexport function getEnumValues(entries) {\n    const numericValues = Object.values(entries).filter((v) => typeof v === \"number\");\n    const values = Object.entries(entries)\n        .filter(([k, _]) => numericValues.indexOf(+k) === -1)\n        .map(([_, v]) => v);\n    return values;\n}\nexport function joinValues(array, separator = \"|\") {\n    return array.map((val) => stringifyPrimitive(val)).join(separator);\n}\nexport function jsonStringifyReplacer(_, value) {\n    if (typeof value === \"bigint\")\n        return value.toString();\n    return value;\n}\nexport function cached(getter) {\n    const set = false;\n    return {\n        get value() {\n            if (!set) {\n                const value = getter();\n                Object.defineProperty(this, \"value\", { value });\n                return value;\n            }\n            throw new Error(\"cached value already set\");\n        },\n    };\n}\nexport function nullish(input) {\n    return input === null || input === undefined;\n}\nexport function cleanRegex(source) {\n    const start = source.startsWith(\"^\") ? 1 : 0;\n    const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n    return source.slice(start, end);\n}\nexport function floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / 10 ** decCount;\n}\nexport function defineLazy(object, key, getter) {\n    const set = false;\n    Object.defineProperty(object, key, {\n        get() {\n            if (!set) {\n                const value = getter();\n                object[key] = value;\n                return value;\n            }\n            throw new Error(\"cached value already set\");\n        },\n        set(v) {\n            Object.defineProperty(object, key, {\n                value: v,\n                // configurable: true,\n            });\n            // object[key] = v;\n        },\n        configurable: true,\n    });\n}\nexport function assignProp(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true,\n    });\n}\nexport function getElementAtPath(obj, path) {\n    if (!path)\n        return obj;\n    return path.reduce((acc, key) => acc?.[key], obj);\n}\nexport function promiseAllObject(promisesObj) {\n    const keys = Object.keys(promisesObj);\n    const promises = keys.map((key) => promisesObj[key]);\n    return Promise.all(promises).then((results) => {\n        const resolvedObj = {};\n        for (let i = 0; i < keys.length; i++) {\n            resolvedObj[keys[i]] = results[i];\n        }\n        return resolvedObj;\n    });\n}\nexport function randomString(length = 10) {\n    const chars = \"abcdefghijklmnopqrstuvwxyz\";\n    let str = \"\";\n    for (let i = 0; i < length; i++) {\n        str += chars[Math.floor(Math.random() * chars.length)];\n    }\n    return str;\n}\nexport function esc(str) {\n    return JSON.stringify(str);\n}\nexport function isObject(data) {\n    return typeof data === \"object\" && data !== null && !Array.isArray(data);\n}\nexport const allowsEval = cached(() => {\n    try {\n        const F = Function;\n        new F(\"\");\n        return true;\n    }\n    catch (_) {\n        return false;\n    }\n});\nexport function isPlainObject(data) {\n    return (typeof data === \"object\" &&\n        data !== null &&\n        (Object.getPrototypeOf(data) === Object.prototype || Object.getPrototypeOf(data) === null));\n}\nexport function numKeys(data) {\n    let keyCount = 0;\n    for (const key in data) {\n        if (Object.prototype.hasOwnProperty.call(data, key)) {\n            keyCount++;\n        }\n    }\n    return keyCount;\n}\nexport const getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return \"undefined\";\n        case \"string\":\n            return \"string\";\n        case \"number\":\n            return Number.isNaN(data) ? \"nan\" : \"number\";\n        case \"boolean\":\n            return \"boolean\";\n        case \"function\":\n            return \"function\";\n        case \"bigint\":\n            return \"bigint\";\n        case \"symbol\":\n            return \"symbol\";\n        case \"object\":\n            if (Array.isArray(data)) {\n                return \"array\";\n            }\n            if (data === null) {\n                return \"null\";\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return \"promise\";\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return \"map\";\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return \"set\";\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return \"date\";\n            }\n            if (typeof File !== \"undefined\" && data instanceof File) {\n                return \"file\";\n            }\n            return \"object\";\n        default:\n            throw new Error(`Unknown data type: ${t}`);\n    }\n};\nexport const propertyKeyTypes = new Set([\"string\", \"number\", \"symbol\"]);\nexport const primitiveTypes = new Set([\"string\", \"number\", \"bigint\", \"boolean\", \"symbol\", \"undefined\"]);\nexport function escapeRegex(str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n// zod-specific utils\nexport function clone(inst, def, params) {\n    const cl = new inst._zod.constr(def ?? inst._zod.def);\n    if (!def || params?.parent)\n        cl._zod.parent = inst;\n    return cl;\n}\nexport function normalizeParams(_params) {\n    const params = _params;\n    if (!params)\n        return {};\n    if (typeof params === \"string\")\n        return { error: () => params };\n    if (params?.message !== undefined) {\n        if (params?.error !== undefined)\n            throw new Error(\"Cannot specify both `message` and `error` params\");\n        params.error = params.message;\n    }\n    delete params.message;\n    if (typeof params.error === \"string\")\n        return { ...params, error: () => params.error };\n    return params;\n}\nexport function createTransparentProxy(getter) {\n    let target;\n    return new Proxy({}, {\n        get(_, prop, receiver) {\n            target ?? (target = getter());\n            return Reflect.get(target, prop, receiver);\n        },\n        set(_, prop, value, receiver) {\n            target ?? (target = getter());\n            return Reflect.set(target, prop, value, receiver);\n        },\n        has(_, prop) {\n            target ?? (target = getter());\n            return Reflect.has(target, prop);\n        },\n        deleteProperty(_, prop) {\n            target ?? (target = getter());\n            return Reflect.deleteProperty(target, prop);\n        },\n        ownKeys(_) {\n            target ?? (target = getter());\n            return Reflect.ownKeys(target);\n        },\n        getOwnPropertyDescriptor(_, prop) {\n            target ?? (target = getter());\n            return Reflect.getOwnPropertyDescriptor(target, prop);\n        },\n        defineProperty(_, prop, descriptor) {\n            target ?? (target = getter());\n            return Reflect.defineProperty(target, prop, descriptor);\n        },\n    });\n}\nexport function stringifyPrimitive(value) {\n    if (typeof value === \"bigint\")\n        return value.toString() + \"n\";\n    if (typeof value === \"string\")\n        return `\"${value}\"`;\n    return `${value}`;\n}\nexport function optionalKeys(shape) {\n    return Object.keys(shape).filter((k) => {\n        return shape[k]._zod.optin === \"optional\" && shape[k]._zod.optout === \"optional\";\n    });\n}\nexport const NUMBER_FORMAT_RANGES = {\n    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n    int32: [-2147483648, 2147483647],\n    uint32: [0, 4294967295],\n    float32: [-3.4028234663852886e38, 3.4028234663852886e38],\n    float64: [-Number.MAX_VALUE, Number.MAX_VALUE],\n};\nexport const BIGINT_FORMAT_RANGES = {\n    int64: [/* @__PURE__*/ BigInt(\"-9223372036854775808\"), /* @__PURE__*/ BigInt(\"9223372036854775807\")],\n    uint64: [/* @__PURE__*/ BigInt(0), /* @__PURE__*/ BigInt(\"18446744073709551615\")],\n};\nexport function pick(schema, mask) {\n    const newShape = {};\n    const currDef = schema._zod.def; //.shape;\n    for (const key in mask) {\n        if (!(key in currDef.shape)) {\n            throw new Error(`Unrecognized key: \"${key}\"`);\n        }\n        if (!mask[key])\n            continue;\n        // pick key\n        newShape[key] = currDef.shape[key];\n    }\n    return clone(schema, {\n        ...schema._zod.def,\n        shape: newShape,\n        checks: [],\n    });\n}\nexport function omit(schema, mask) {\n    const newShape = { ...schema._zod.def.shape };\n    const currDef = schema._zod.def; //.shape;\n    for (const key in mask) {\n        if (!(key in currDef.shape)) {\n            throw new Error(`Unrecognized key: \"${key}\"`);\n        }\n        if (!mask[key])\n            continue;\n        delete newShape[key];\n    }\n    return clone(schema, {\n        ...schema._zod.def,\n        shape: newShape,\n        checks: [],\n    });\n}\nexport function extend(schema, shape) {\n    const def = {\n        ...schema._zod.def,\n        get shape() {\n            const _shape = { ...schema._zod.def.shape, ...shape };\n            assignProp(this, \"shape\", _shape); // self-caching\n            return _shape;\n        },\n        checks: [], // delete existing checks\n    };\n    return clone(schema, def);\n}\nexport function merge(a, b) {\n    return clone(a, {\n        ...a._zod.def,\n        get shape() {\n            const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };\n            assignProp(this, \"shape\", _shape); // self-caching\n            return _shape;\n        },\n        catchall: b._zod.def.catchall,\n        checks: [], // delete existing checks\n    });\n}\nexport function partial(Class, schema, mask) {\n    const oldShape = schema._zod.def.shape;\n    const shape = { ...oldShape };\n    if (mask) {\n        for (const key in mask) {\n            if (!(key in oldShape)) {\n                throw new Error(`Unrecognized key: \"${key}\"`);\n            }\n            if (!mask[key])\n                continue;\n            shape[key] = Class\n                ? new Class({\n                    type: \"optional\",\n                    innerType: oldShape[key],\n                })\n                : oldShape[key];\n        }\n    }\n    else {\n        for (const key in oldShape) {\n            shape[key] = Class\n                ? new Class({\n                    type: \"optional\",\n                    innerType: oldShape[key],\n                })\n                : oldShape[key];\n        }\n    }\n    return clone(schema, {\n        ...schema._zod.def,\n        shape,\n        checks: [],\n    });\n}\nexport function required(Class, schema, mask) {\n    const oldShape = schema._zod.def.shape;\n    const shape = { ...oldShape };\n    if (mask) {\n        for (const key in mask) {\n            if (!(key in shape)) {\n                throw new Error(`Unrecognized key: \"${key}\"`);\n            }\n            if (!mask[key])\n                continue;\n            // overwrite with non-optional\n            shape[key] = new Class({\n                type: \"nonoptional\",\n                innerType: oldShape[key],\n            });\n        }\n    }\n    else {\n        for (const key in oldShape) {\n            // overwrite with non-optional\n            shape[key] = new Class({\n                type: \"nonoptional\",\n                innerType: oldShape[key],\n            });\n        }\n    }\n    return clone(schema, {\n        ...schema._zod.def,\n        shape,\n        // optional: [],\n        checks: [],\n    });\n}\nexport function aborted(x, startIndex = 0) {\n    for (let i = startIndex; i < x.issues.length; i++) {\n        if (x.issues[i].continue !== true)\n            return true;\n    }\n    return false;\n}\nexport function prefixIssues(path, issues) {\n    return issues.map((iss) => {\n        var _a;\n        (_a = iss).path ?? (_a.path = []);\n        iss.path.unshift(path);\n        return iss;\n    });\n}\nexport function unwrapMessage(message) {\n    return typeof message === \"string\" ? message : message?.message;\n}\nexport function finalizeIssue(iss, ctx, config) {\n    const full = { ...iss, path: iss.path ?? [] };\n    // for backwards compatibility\n    if (!iss.message) {\n        const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ??\n            unwrapMessage(ctx?.error?.(iss)) ??\n            unwrapMessage(config.customError?.(iss)) ??\n            unwrapMessage(config.localeError?.(iss)) ??\n            \"Invalid input\";\n        full.message = message;\n    }\n    // delete (full as any).def;\n    delete full.inst;\n    delete full.continue;\n    if (!ctx?.reportInput) {\n        delete full.input;\n    }\n    return full;\n}\nexport function getSizableOrigin(input) {\n    if (input instanceof Set)\n        return \"set\";\n    if (input instanceof Map)\n        return \"map\";\n    if (input instanceof File)\n        return \"file\";\n    return \"unknown\";\n}\nexport function getLengthableOrigin(input) {\n    if (Array.isArray(input))\n        return \"array\";\n    if (typeof input === \"string\")\n        return \"string\";\n    return \"unknown\";\n}\nexport function issue(...args) {\n    const [iss, input, inst] = args;\n    if (typeof iss === \"string\") {\n        return {\n            message: iss,\n            code: \"custom\",\n            input,\n            inst,\n        };\n    }\n    return { ...iss };\n}\nexport function cleanEnum(obj) {\n    return Object.entries(obj)\n        .filter(([k, _]) => {\n        // return true if NaN, meaning it's not a number, thus a string key\n        return Number.isNaN(Number.parseInt(k, 10));\n    })\n        .map((el) => el[1]);\n}\n// instanceof\nexport class Class {\n    constructor(..._args) { }\n}\n", "import { $constructor } from \"./core.js\";\nimport * as util from \"./util.js\";\nconst initializer = (inst, def) => {\n    inst.name = \"$ZodError\";\n    Object.defineProperty(inst, \"_zod\", {\n        value: inst._zod,\n        enumerable: false,\n    });\n    Object.defineProperty(inst, \"issues\", {\n        value: def,\n        enumerable: false,\n    });\n    Object.defineProperty(inst, \"message\", {\n        get() {\n            return JSON.stringify(def, util.jsonStringifyReplacer, 2);\n        },\n        enumerable: true,\n        // configurable: false,\n    });\n};\nexport const $ZodError = $constructor(\"$ZodError\", initializer);\nexport const $ZodRealError = $constructor(\"$ZodError\", initializer, { Parent: Error });\nexport function flattenError(error, mapper = (issue) => issue.message) {\n    const fieldErrors = {};\n    const formErrors = [];\n    for (const sub of error.issues) {\n        if (sub.path.length > 0) {\n            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n            fieldErrors[sub.path[0]].push(mapper(sub));\n        }\n        else {\n            formErrors.push(mapper(sub));\n        }\n    }\n    return { formErrors, fieldErrors };\n}\nexport function formatError(error, _mapper) {\n    const mapper = _mapper ||\n        function (issue) {\n            return issue.message;\n        };\n    const fieldErrors = { _errors: [] };\n    const processError = (error) => {\n        for (const issue of error.issues) {\n            if (issue.code === \"invalid_union\" && issue.errors.length) {\n                issue.errors.map((issues) => processError({ issues }));\n            }\n            else if (issue.code === \"invalid_key\") {\n                processError({ issues: issue.issues });\n            }\n            else if (issue.code === \"invalid_element\") {\n                processError({ issues: issue.issues });\n            }\n            else if (issue.path.length === 0) {\n                fieldErrors._errors.push(mapper(issue));\n            }\n            else {\n                let curr = fieldErrors;\n                let i = 0;\n                while (i < issue.path.length) {\n                    const el = issue.path[i];\n                    const terminal = i === issue.path.length - 1;\n                    if (!terminal) {\n                        curr[el] = curr[el] || { _errors: [] };\n                    }\n                    else {\n                        curr[el] = curr[el] || { _errors: [] };\n                        curr[el]._errors.push(mapper(issue));\n                    }\n                    curr = curr[el];\n                    i++;\n                }\n            }\n        }\n    };\n    processError(error);\n    return fieldErrors;\n}\nexport function treeifyError(error, _mapper) {\n    const mapper = _mapper ||\n        function (issue) {\n            return issue.message;\n        };\n    const result = { errors: [] };\n    const processError = (error, path = []) => {\n        var _a, _b;\n        for (const issue of error.issues) {\n            if (issue.code === \"invalid_union\" && issue.errors.length) {\n                // regular union error\n                issue.errors.map((issues) => processError({ issues }, issue.path));\n            }\n            else if (issue.code === \"invalid_key\") {\n                processError({ issues: issue.issues }, issue.path);\n            }\n            else if (issue.code === \"invalid_element\") {\n                processError({ issues: issue.issues }, issue.path);\n            }\n            else {\n                const fullpath = [...path, ...issue.path];\n                if (fullpath.length === 0) {\n                    result.errors.push(mapper(issue));\n                    continue;\n                }\n                let curr = result;\n                let i = 0;\n                while (i < fullpath.length) {\n                    const el = fullpath[i];\n                    const terminal = i === fullpath.length - 1;\n                    if (typeof el === \"string\") {\n                        curr.properties ?? (curr.properties = {});\n                        (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });\n                        curr = curr.properties[el];\n                    }\n                    else {\n                        curr.items ?? (curr.items = []);\n                        (_b = curr.items)[el] ?? (_b[el] = { errors: [] });\n                        curr = curr.items[el];\n                    }\n                    if (terminal) {\n                        curr.errors.push(mapper(issue));\n                    }\n                    i++;\n                }\n            }\n        }\n    };\n    processError(error);\n    return result;\n}\n/** Format a ZodError as a human-readable string in the following form.\n *\n * From\n *\n * ```ts\n * ZodError {\n *   issues: [\n *     {\n *       expected: 'string',\n *       code: 'invalid_type',\n *       path: [ 'username' ],\n *       message: 'Invalid input: expected string'\n *     },\n *     {\n *       expected: 'number',\n *       code: 'invalid_type',\n *       path: [ 'favoriteNumbers', 1 ],\n *       message: 'Invalid input: expected number'\n *     }\n *   ];\n * }\n * ```\n *\n * to\n *\n * ```\n * username\n *   ✖ Expected number, received string at \"username\n * favoriteNumbers[0]\n *   ✖ Invalid input: expected number\n * ```\n */\nexport function toDotPath(path) {\n    const segs = [];\n    for (const seg of path) {\n        if (typeof seg === \"number\")\n            segs.push(`[${seg}]`);\n        else if (typeof seg === \"symbol\")\n            segs.push(`[${JSON.stringify(String(seg))}]`);\n        else if (/[^\\w$]/.test(seg))\n            segs.push(`[${JSON.stringify(seg)}]`);\n        else {\n            if (segs.length)\n                segs.push(\".\");\n            segs.push(seg);\n        }\n    }\n    return segs.join(\"\");\n}\nexport function prettifyError(error) {\n    const lines = [];\n    // sort by path length\n    const issues = [...error.issues].sort((a, b) => a.path.length - b.path.length);\n    // Process each issue\n    for (const issue of issues) {\n        lines.push(`✖ ${issue.message}`);\n        if (issue.path?.length)\n            lines.push(`  → at ${toDotPath(issue.path)}`);\n    }\n    // Convert Map to formatted string\n    return lines.join(\"\\n\");\n}\n", "import * as core from \"./core.js\";\nimport * as errors from \"./errors.js\";\nimport * as util from \"./util.js\";\nexport const _parse = (_Err) => (schema, value, _ctx, _params) => {\n    const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };\n    const result = schema._zod.run({ value, issues: [] }, ctx);\n    if (result instanceof Promise) {\n        throw new core.$ZodAsyncError();\n    }\n    if (result.issues.length) {\n        const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())));\n        Error.captureStackTrace(e, _params?.callee);\n        throw e;\n    }\n    return result.value;\n};\nexport const parse = /* @__PURE__*/ _parse(errors.$ZodRealError);\nexport const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {\n    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n    let result = schema._zod.run({ value, issues: [] }, ctx);\n    if (result instanceof Promise)\n        result = await result;\n    if (result.issues.length) {\n        const e = new (params?.Err ?? _Err)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())));\n        Error.captureStackTrace(e, params?.callee);\n        throw e;\n    }\n    return result.value;\n};\nexport const parseAsync = /* @__PURE__*/ _parseAsync(errors.$ZodRealError);\nexport const _safeParse = (_Err) => (schema, value, _ctx) => {\n    const ctx = _ctx ? { ..._ctx, async: false } : { async: false };\n    const result = schema._zod.run({ value, issues: [] }, ctx);\n    if (result instanceof Promise) {\n        throw new core.$ZodAsyncError();\n    }\n    return result.issues.length\n        ? {\n            success: false,\n            error: new (_Err ?? errors.$ZodError)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),\n        }\n        : { success: true, data: result.value };\n};\nexport const safeParse = /* @__PURE__*/ _safeParse(errors.$ZodRealError);\nexport const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {\n    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n    let result = schema._zod.run({ value, issues: [] }, ctx);\n    if (result instanceof Promise)\n        result = await result;\n    return result.issues.length\n        ? {\n            success: false,\n            error: new _Err(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),\n        }\n        : { success: true, data: result.value };\n};\nexport const safeParseAsync = /* @__PURE__*/ _safeParseAsync(errors.$ZodRealError);\n", "import { toNestErrors, validateFieldsNatively } from '@hookform/resolvers';\nimport {\n  FieldError,\n  FieldErrors,\n  FieldValues,\n  Resolver,\n  ResolverError,\n  ResolverSuccess,\n  appendErrors,\n} from 'react-hook-form';\nimport * as z3 from 'zod/v3';\nimport * as z4 from 'zod/v4/core';\n\nconst isZod3Error = (error: any): error is z3.ZodError => {\n  return Array.isArray(error?.issues);\n};\nconst isZod3Schema = (schema: any): schema is z3.ZodSchema => {\n  return (\n    '_def' in schema &&\n    typeof schema._def === 'object' &&\n    'typeName' in schema._def\n  );\n};\nconst isZod4Error = (error: any): error is z4.$ZodError => {\n  // instanceof is safe in Zod 4 (uses Symbol.hasInstance)\n  return error instanceof z4.$ZodError;\n};\nconst isZod4Schema = (schema: any): schema is z4.$ZodType => {\n  return '_zod' in schema && typeof schema._zod === 'object';\n};\n\nfunction parseZod3Issues(\n  zodErrors: z3.ZodIssue[],\n  validateAllFieldCriteria: boolean,\n) {\n  const errors: Record<string, FieldError> = {};\n  for (; zodErrors.length; ) {\n    const error = zodErrors[0];\n    const { code, message, path } = error;\n    const _path = path.join('.');\n\n    if (!errors[_path]) {\n      if ('unionErrors' in error) {\n        const unionError = error.unionErrors[0].errors[0];\n\n        errors[_path] = {\n          message: unionError.message,\n          type: unionError.code,\n        };\n      } else {\n        errors[_path] = { message, type: code };\n      }\n    }\n\n    if ('unionErrors' in error) {\n      error.unionErrors.forEach((unionError) =>\n        unionError.errors.forEach((e) => zodErrors.push(e)),\n      );\n    }\n\n    if (validateAllFieldCriteria) {\n      const types = errors[_path].types;\n      const messages = types && types[error.code];\n\n      errors[_path] = appendErrors(\n        _path,\n        validateAllFieldCriteria,\n        errors,\n        code,\n        messages\n          ? ([] as string[]).concat(messages as string[], error.message)\n          : error.message,\n      ) as FieldError;\n    }\n\n    zodErrors.shift();\n  }\n\n  return errors;\n}\n\nfunction parseZod4Issues(\n  zodErrors: z4.$ZodIssue[],\n  validateAllFieldCriteria: boolean,\n) {\n  const errors: Record<string, FieldError> = {};\n  // const _zodErrors = zodErrors as z4.$ZodISsue; //\n  for (; zodErrors.length; ) {\n    const error = zodErrors[0];\n    const { code, message, path } = error;\n    const _path = path.join('.');\n\n    if (!errors[_path]) {\n      if (error.code === 'invalid_union') {\n        const unionError = error.errors[0][0];\n\n        errors[_path] = {\n          message: unionError.message,\n          type: unionError.code,\n        };\n      } else {\n        errors[_path] = { message, type: code };\n      }\n    }\n\n    if (error.code === 'invalid_union') {\n      error.errors.forEach((unionError) =>\n        unionError.forEach((e) => zodErrors.push(e)),\n      );\n    }\n\n    if (validateAllFieldCriteria) {\n      const types = errors[_path].types;\n      const messages = types && types[error.code];\n\n      errors[_path] = appendErrors(\n        _path,\n        validateAllFieldCriteria,\n        errors,\n        code,\n        messages\n          ? ([] as string[]).concat(messages as string[], error.message)\n          : error.message,\n      ) as FieldError;\n    }\n\n    zodErrors.shift();\n  }\n\n  return errors;\n}\n\ntype RawResolverOptions = {\n  mode?: 'async' | 'sync';\n  raw: true;\n};\ntype NonRawResolverOptions = {\n  mode?: 'async' | 'sync';\n  raw?: false;\n};\n\n// minimal interfaces to avoid asssignability issues between versions\ninterface Zod3Type<O = unknown, I = unknown> {\n  _output: O;\n  _input: I;\n  _def: {\n    typeName: string;\n  };\n}\n\n// some type magic to make versions pre-3.25.0 still work\ntype IsUnresolved<T> = PropertyKey extends keyof T ? true : false;\ntype UnresolvedFallback<T, Fallback> = IsUnresolved<typeof z3> extends true\n  ? Fallback\n  : T;\ntype FallbackIssue = {\n  code: string;\n  message: string;\n  path: (string | number)[];\n};\ntype Zod3ParseParams = UnresolvedFallback<\n  z3.ParseParams,\n  // fallback if user is on <3.25.0\n  {\n    path?: (string | number)[];\n    errorMap?: (\n      iss: FallbackIssue,\n      ctx: {\n        defaultError: string;\n        data: any;\n      },\n    ) => { message: string };\n    async?: boolean;\n  }\n>;\ntype Zod4ParseParams = UnresolvedFallback<\n  z4.ParseContext<z4.$ZodIssue>,\n  // fallback if user is on <3.25.0\n  {\n    readonly error?: (\n      iss: FallbackIssue,\n    ) => null | undefined | string | { message: string };\n    readonly reportInput?: boolean;\n    readonly jitless?: boolean;\n  }\n>;\n\nexport function zodResolver<Input extends FieldValues, Context, Output>(\n  schema: Zod3Type<Output, Input>,\n  schemaOptions?: Zod3ParseParams,\n  resolverOptions?: NonRawResolverOptions,\n): Resolver<Input, Context, Output>;\nexport function zodResolver<Input extends FieldValues, Context, Output>(\n  schema: Zod3Type<Output, Input>,\n  schemaOptions: Zod3ParseParams | undefined,\n  resolverOptions: RawResolverOptions,\n): Resolver<Input, Context, Input>;\n// the Zod 4 overloads need to be generic for complicated reasons\nexport function zodResolver<\n  Input extends FieldValues,\n  Context,\n  Output,\n  T extends z4.$ZodType<Output, Input> = z4.$ZodType<Output, Input>,\n>(\n  schema: T,\n  schemaOptions?: Zod4ParseParams, // already partial\n  resolverOptions?: NonRawResolverOptions,\n): Resolver<z4.input<T>, Context, z4.output<T>>;\nexport function zodResolver<\n  Input extends FieldValues,\n  Context,\n  Output,\n  T extends z4.$ZodType<Output, Input> = z4.$ZodType<Output, Input>,\n>(\n  schema: z4.$ZodType<Output, Input>,\n  schemaOptions: Zod4ParseParams | undefined, // already partial\n  resolverOptions: RawResolverOptions,\n): Resolver<z4.input<T>, Context, z4.input<T>>;\n/**\n * Creates a resolver function for react-hook-form that validates form data using a Zod schema\n * @param {z3.ZodSchema<Input>} schema - The Zod schema used to validate the form data\n * @param {Partial<z3.ParseParams>} [schemaOptions] - Optional configuration options for Zod parsing\n * @param {Object} [resolverOptions] - Optional resolver-specific configuration\n * @param {('async'|'sync')} [resolverOptions.mode='async'] - Validation mode. Use 'sync' for synchronous validation\n * @param {boolean} [resolverOptions.raw=false] - If true, returns the raw form values instead of the parsed data\n * @returns {Resolver<z3.output<typeof schema>>} A resolver function compatible with react-hook-form\n * @throws {Error} Throws if validation fails with a non-Zod error\n * @example\n * const schema = z3.object({\n *   name: z3.string().min(2),\n *   age: z3.number().min(18)\n * });\n *\n * useForm({\n *   resolver: zodResolver(schema)\n * });\n */\nexport function zodResolver<Input extends FieldValues, Context, Output>(\n  schema: object,\n  schemaOptions?: object,\n  resolverOptions: {\n    mode?: 'async' | 'sync';\n    raw?: boolean;\n  } = {},\n): Resolver<Input, Context, Output | Input> {\n  if (isZod3Schema(schema)) {\n    return async (values: Input, _, options) => {\n      try {\n        const data = await schema[\n          resolverOptions.mode === 'sync' ? 'parse' : 'parseAsync'\n        ](values, schemaOptions);\n\n        options.shouldUseNativeValidation &&\n          validateFieldsNatively({}, options);\n\n        return {\n          errors: {} as FieldErrors,\n          values: resolverOptions.raw ? Object.assign({}, values) : data,\n        } satisfies ResolverSuccess<Output | Input>;\n      } catch (error) {\n        if (isZod3Error(error)) {\n          return {\n            values: {},\n            errors: toNestErrors(\n              parseZod3Issues(\n                error.errors,\n                !options.shouldUseNativeValidation &&\n                  options.criteriaMode === 'all',\n              ),\n              options,\n            ),\n          } satisfies ResolverError<Input>;\n        }\n\n        throw error;\n      }\n    };\n  }\n\n  if (isZod4Schema(schema)) {\n    return async (values: Input, _, options) => {\n      try {\n        const parseFn =\n          resolverOptions.mode === 'sync' ? z4.parse : z4.parseAsync;\n        const data: any = await parseFn(schema, values, schemaOptions);\n\n        options.shouldUseNativeValidation &&\n          validateFieldsNatively({}, options);\n\n        return {\n          errors: {} as FieldErrors,\n          values: resolverOptions.raw ? Object.assign({}, values) : data,\n        } satisfies ResolverSuccess<Output | Input>;\n      } catch (error) {\n        if (isZod4Error(error)) {\n          return {\n            values: {},\n            errors: toNestErrors(\n              parseZod4Issues(\n                error.issues,\n                !options.shouldUseNativeValidation &&\n                  options.criteriaMode === 'all',\n              ),\n              options,\n            ),\n          } satisfies ResolverError<Input>;\n        }\n\n        throw error;\n      }\n    };\n  }\n\n  throw new Error('Invalid input: not a Zod schema');\n}\n"],
  "mappings": "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",
  "names": ["setCustomValidity", "ref", "fieldPath", "errors", "error", "get", "message", "reportValidity", "validateFieldsNatively", "options", "fields", "field", "refs", "forEach", "toNestErrors", "shouldUseNativeValidation", "fieldErrors", "path", "Object", "assign", "isNameInFieldArray", "names", "keys", "fieldArrayErrors", "set", "name", "escapeBrackets", "some", "n", "match", "input", "replace", "$constructor", "name", "initializer", "params", "init", "inst", "def", "_a", "Object", "defineProperty", "value", "_zod", "enumerable", "traits", "Set", "add", "k", "_", "prototype", "bind", "constr", "Parent", "Definition", "this", "deferred", "fn", "Symbol", "hasInstance", "has", "$ZodAsyncError", "Error", "constructor", "super", "globalConfig", "config", "newConfig", "assign", "jsonStringifyReplacer", "toString", "unwrapMessage", "message", "finalizeIssue", "iss", "ctx", "full", "path", "error", "customError", "localeError", "continue", "reportInput", "input", "get", "JSON", "stringify", "util.jsonStringifyReplacer", "$ZodError", "$ZodRealError", "parse", "_Err", "schema", "_ctx", "_params", "async", "result", "run", "issues", "Promise", "core.$ZodAsyncError", "length", "e", "Err", "map", "util.finalizeIssue", "core.config", "captureStackTrace", "callee", "errors.$ZodRealError", "parseAsync", "parseZod3Issues", "zodErrors", "validateAllFieldCriteria", "errors", "code", "_path", "join", "unionError", "unionErrors", "type", "forEach", "push", "types", "messages", "appendErrors", "concat", "shift", "parseZod4Issues", "zodResolver", "schemaOptions", "resolverOptions", "_def", "values", "options", "resolve", "_catch", "mode", "then", "data", "shouldUseNativeValidation", "validateFieldsNatively", "raw", "Array", "isArray", "toNestErrors", "criteriaMode", "reject", "z4"]
}
